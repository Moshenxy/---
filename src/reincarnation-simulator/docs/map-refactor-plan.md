# 世界沙盘重构最终方案 v6.0：AI为“关系定义者”，前端为“布局解释器”

## 核心矛盾
根据用户反馈，之前所有要求AI提供坐标或几何数据的方案均存在根本性缺陷。AI作为文本模型，不具备空间感知能力，无法判断自己生成的坐标和尺寸在视觉上是否合理。直接让前端解析自然语言描述同样不可行。

## 最终方案：结构化关系定义
我们必须采用一个AI和前端都能明确理解的“共同语言”。方案核心是：
- **AI的职责 -> 关系定义者**: AI不再提供任何几何数据或自然语言描述。它的唯一职责是定义实体之间的**结构化关系**。
- **前端的职责 -> 布局解释器**: 前端将升级为一个智能的“制图引擎”，负责**解释**这些结构化关系，并将其**翻译**成物理模拟中的“力”，最终生成一张视觉上合理且美观的动态地图。

---

### 第一阶段：引入结构化的 `positioning` 字段

我们将彻底废除 `位置描述` 字符串，代之以一个名为 `positioning` 的、结构化的对象数组。

**AI生成的数据格式示例：**
```yaml
- ID: city_yandu_01
  名称: 燕都
  类型: 城市
  所属: nation_pacific_union_01  # 用于生成核心引力
  规模: 巨型                     # 用于定义碰撞体积和斥力
  positioning: # 新增的结构化定位字段
    - type: "relative_to"    # 类型：相对于另一个实体
      target: "geomorphy_himalayas_01" # 参考实体的ID
      direction: "E"         # 方位枚举 (N, S, E, W, NE, NW, SE, SW, center)
      distance_ratio: 0.8    # 距离比例：占参考实体半径的80%

- ID: geomorphy_himalayas_01
  类型: "山脉"
  名称: 喜马拉雅山脉
  所属: plate_eurasian_01
  规模: 巨型
  positioning:
    - type: "parent_anchor"  # 类型：锚定在父实体的某个方位
      direction: "SW"        # 方位枚举: 西南
```
此格式对AI极其友好，因为它只涉及ID复制和枚举值选择。

---

### 第二阶段：前端“定位力”的真正实现

前端的自定义力不再是NLP引擎，而是一个简单的**规则解释器**。

**`MapDataProcessor.ts` 的新工作原理：**

1.  **遍历节点**: 在物理模拟的每一帧，遍历所有节点。
2.  **读取`positioning`规则**: 检查每个节点的 `positioning` 数组。
3.  **解释规则并施加“力”**:
    *   **对于 `type: "parent_anchor"`**:
        *   找到该节点的父节点（通过`所属`关系）。
        *   根据 `direction`（例如`"SW"`），计算出父节点边界内西南方向的一个目标坐标 `(targetX, targetY)`。
        *   施加一个微弱的、持续的力，将当前节点**“推向”** `(targetX, targetY)`。

    *   **对于 `type: "relative_to"`**:
        *   找到 `target` ID对应的参考节点。
        *   根据 `direction` 和 `distance_ratio`，计算出参考节点周围的一个目标坐标。
        *   施加一个力，将当前节点**“推向”**该目标坐标。

这个过程的本质是执行明确的指令：“**对A施加一个朝向B的C方向的力**”，完全是前端擅长的数学和物理计算。

### 完整工作流（最终版）

1.  **AI生成**: AI生成包含 `所属`, `规模`, 和新的结构化 `positioning` 字段的YAML。
2.  **前端解析**: 前端解析YAML，获得实体和它们之间的关系定义。
3.  **力模拟设置**: `MapDataProcessor` 设置 `d3-force` 模拟：
    *   `forceLink` 根据 `所属` 关系建立父子引力。
    *   `forceCollide` 根据 `规模` 设定碰撞体积。
    *   **`forcePositioning` (新)** 读取 `positioning` 数组，对每个节点施加额外的、定向的“定位力”。
4.  **布局计算**: 模拟开始。在多种力的共同作用下，所有节点会动态地移动，最终稳定在一个既符合层级关系、又不重叠、且大致满足AI定义的相对位置的最终布局上。
5.  **程序化渲染**: 使用稳定后的布局骨架（每个节点的x, y坐标和半径），调用 `generateIrregularPath` 等函数，绘制出最终美观的疆域和地貌。

此方案是技术上完全可行的最终蓝图，完美地划分了AI和前端的职责，解决了所有已知问题。
